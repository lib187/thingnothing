1. C代码中的变参
  这里以日志函数为例:
    #define log(fmt, args...) do { Log("[%s:%s():%d] " fmt, __FILE__,  __func__, __LINE__, ##args); }while(0)

    void Log(const char *pcFmt, ...)
    {
      // e.g. log("ABC");
      // 宏替换后Deploy_Log("[%s:%s():%d] " "ABC", __FILE__,  __func__, __LINE__, ##args)
      // 即 Deploy_Log("[%s:%s():%d] ABC", __FILE__,  __func__, __LINE__, ##args)
      // 此时pcFmt == "[%s:%s():%d] ABC"

      va_list pcArgs;
      // 	void va_start(va_list ap, last_arg) 这个宏初始化ap变量，它与va_arg和va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数
      va_start(pcArgs, pcFmt);  // pcArgs == (__FILE__,  __func__, __LINE__, ##args) 

      // 此时acLogBuf = printf("[%s:%s():%d] ABC", __FILE__,  __func__, __LINE__)
      (void)vsnprintf(acLogBuf, DEPLOY_LOGMSG_MAX_LEN, pcFmt, pcArgs); 
      // void va_end(va_list ap)这个宏允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。
      va_end(pcArgs); 
    }
   进一步的用法，如果我想封装一个Malloc, 函数中可以打印调用Malloc时的代码位置(类似log)，可以打印返malloc的返回值
   这里有一点需要将变参传递下去，这里可以参考https://my.oschina.net/u/1429862/blog/222903
      void Category::_logUnconditionally(Priority::Value priority, const char* format, va_list arguments) throw() 
      {
          _logUnconditionally2(priority, StringUtil::vform(format, arguments));
      }

      void Category::log(Priority::Value priority, const char* stringFormat, ...) throw() 
      { 
              if (isPriorityEnabled(priority)) 
              {
                  va_list va;
                  va_start(va, stringFormat);
                  _logUnconditionally(priority, stringFormat, va);
                  va_end(va);
              }
      }

2. C语言中参数的默认值的问题，好像只能用宏定义来实现


3. Linux中的线程获取， gdb是的LWP

4. 重入、线程安全、信号安全
  信号引起的死锁问题https://www.cnblogs.com/solohac/p/4154183.html

